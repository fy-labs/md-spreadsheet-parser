{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Markdown Spreadsheet Parser","text":"<p>A lightweight, pure Python library for parsing Markdown tables into structured data. Designed to be portable and run in WebAssembly environments (like Pyodide in VS Code extensions).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Python: Zero dependencies, runs anywhere Python runs (including WASM).</li> <li>Structured Output: Converts Markdown tables into JSON-friendly objects with headers and rows.</li> <li>Multi-Table Support: Can parse multiple tables (sheets) from a single file using a specific structure.</li> <li>Configurable: Supports different table styles via schemas.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install md-spreadsheet-parser\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-basic-parsing","title":"1. Basic Parsing","text":""},{"location":"#single-table","title":"Single Table","text":"<p>Parse a standard Markdown table into a structured object.</p> <pre><code>from md_spreadsheet_parser import parse_table\n\nmarkdown = \"\"\"\n| Name | Age |\n| --- | --- |\n| Alice | 30 |\n| Bob | 25 |\n\"\"\"\n\nresult = parse_table(markdown)\n\nprint(result.headers)\n# ['Name', 'Age']\n\nprint(result.rows)\n# [['Alice', '30'], ['Bob', '25']]\n</code></pre>"},{"location":"#multiple-tables-workbook","title":"Multiple Tables (Workbook)","text":"<p>Parse a file containing multiple sheets (sections). By default, it looks for <code># Tables</code> as the root marker and <code>## Sheet Name</code> for sheets.</p> <pre><code>from md_spreadsheet_parser import parse_workbook, MultiTableParsingSchema\n\nmarkdown = \"\"\"\n# Tables\n\n## Users\n| ID | Name |\n| -- | ---- |\n| 1  | Alice|\n\n## Products\n| ID | Item |\n| -- | ---- |\n| A  | Apple|\n\"\"\"\n\n# Use default schema\nschema = MultiTableParsingSchema()\nworkbook = parse_workbook(markdown, schema)\n\nfor sheet in workbook.sheets:\n    print(f\"Sheet: {sheet.name}\")\n    for table in sheet.tables:\n        print(table.rows)\n</code></pre>"},{"location":"#2-advanced-features","title":"2. Advanced Features","text":""},{"location":"#metadata-extraction-table-names-descriptions","title":"Metadata Extraction (Table Names &amp; Descriptions)","text":"<p>You can configure the parser to extract table names (from headers) and descriptions (text preceding the table).</p> <pre><code>from md_spreadsheet_parser import parse_workbook, MultiTableParsingSchema\n\nmarkdown = \"\"\"\n# Tables\n\n## Sales Data\n\n### Q1 Results\nFinancial performance for the first quarter.\n\n| Month | Revenue |\n| ----- | ------- |\n| Jan   | 1000    |\n\"\"\"\n\n# Configure schema to capture table headers (level 3) and descriptions\nschema = MultiTableParsingSchema(\n    table_header_level=3,     # Treat ### Header as table name\n    capture_description=True  # Capture text between header and table\n)\n\nworkbook = parse_workbook(markdown, schema)\ntable = workbook.sheets[0].tables[0]\n\nprint(f\"Table: {table.name}\")        # \"Q1 Results\"\nprint(f\"Desc: {table.description}\")  # \"Financial performance for the first quarter.\"\n</code></pre>"},{"location":"#lookup-api","title":"Lookup API","text":"<p>Retrieve sheets and tables directly by name instead of iterating.</p> <pre><code>sheet = workbook.get_sheet(\"Sales Data\")\nif sheet:\n    table = sheet.get_table(\"Q1 Results\")\n    if table:\n        print(table.rows)\n</code></pre>"},{"location":"#simple-scan-interface","title":"Simple Scan Interface","text":"<p>If you want to extract all tables from a document regardless of its structure (ignoring sheets and headers), use <code>scan_tables</code>.</p> <p>Example 1: Basic Scanning Extract all tables from a text, ignoring headers and other content.</p> <pre><code>from md_spreadsheet_parser import scan_tables\n\nmarkdown = \"\"\"\nSome introductory text...\n\n| A | B |\n| - | - |\n| 1 | 2 |\n\nMore text...\n\n| C |\n| - |\n| 3 |\n\"\"\"\n\n# Returns a flat list of all tables found\ntables = scan_tables(markdown)\n\nprint(len(tables)) # 2\nprint(tables[0].headers) # ['A', 'B']\n</code></pre> <p>Example 2: Metadata Extraction (Flat File) You can use <code>MultiTableParsingSchema</code> with <code>scan_tables</code> to extract table names and descriptions even without a root marker or sheets. This is useful for flat Markdown files.</p> <pre><code>from md_spreadsheet_parser import scan_tables, MultiTableParsingSchema\n\nmarkdown = \"\"\"\n### Users\nList of users.\n\n| Name | Age |\n| ---- | --- |\n| Alice| 30  |\n\n### Products\nList of products.\n\n| Item | Price |\n| ---- | ----- |\n| Apple| 1.00  |\n\"\"\"\n\n# Configure schema to capture table headers and descriptions\nschema = MultiTableParsingSchema(\n    table_header_level=3,\n    capture_description=True\n)\n\ntables = scan_tables(markdown, schema)\n\nfor table in tables:\n    print(f\"Table: {table.name}\")        # \"Users\", \"Products\"\n    print(f\"Desc: {table.description}\")  # \"List of users.\", \"List of products.\"\n    print(table.rows)\n</code></pre> <p>Example 3: Mixed Content Handling <code>scan_tables</code> is robust against mixed content. It will identify tables based on the schema (column separator) and ignore other text blocks unless configured to capture them as descriptions.</p> <pre><code>markdown = \"\"\"\n# Title\nIntroduction paragraph.\n\n| Col 1 |\n| ----- |\n| Val 1 |\n\n&gt; Blockquote that is not a table.\n\n| Col 2 |\n| ----- |\n| Val 2 |\n\"\"\"\n\ntables = scan_tables(markdown)\n# tables[0] -&gt; Table with header ['Col 1']\n# tables[1] -&gt; Table with header ['Col 2']\n</code></pre>"},{"location":"#json-dict-export","title":"JSON / Dict Export","text":"<p>All result objects (<code>Workbook</code>, <code>Sheet</code>, <code>Table</code>) have a <code>.json</code> property that returns a dictionary, making it easy to serialize or pass to other libraries (like Pandas).</p> <pre><code>import json\nimport pandas as pd\n\n# Export to JSON\nprint(json.dumps(workbook.json, indent=2))\n\n# Convert to Pandas DataFrame\ntable_data = workbook.sheets[0].tables[0].json\ndf = pd.DataFrame(table_data[\"rows\"], columns=table_data[\"headers\"])\n</code></pre>"},{"location":"#3-configuration-schemas","title":"3. Configuration (Schemas)","text":"<p>You can customize parsing behavior using <code>ParsingSchema</code> and <code>MultiTableParsingSchema</code>.</p> Option Default Description <code>column_separator</code> <code>\\|</code> Character used to separate columns. <code>header_separator_char</code> <code>-</code> Character used in the separator row (e.g. <code>---</code>). <code>strip_whitespace</code> <code>True</code> Whether to strip whitespace from cell values. <code>root_marker</code> <code># Tables</code> (Multi-table only) Marker indicating start of data. <code>sheet_header_level</code> <code>2</code> (Multi-table only) Header level for sheets (e.g. <code>##</code>). <code>table_header_level</code> <code>None</code> (Multi-table only) Header level for tables. <code>None</code> disables name extraction. <code>capture_description</code> <code>False</code> (Multi-table only) Whether to capture text descriptions. <pre><code>schema = MultiTableParsingSchema(\n    root_marker=\"# My Data\",\n    sheet_header_level=1,\n    strip_whitespace=False\n)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#md_spreadsheet_parser.core","title":"<code>md_spreadsheet_parser.core</code>","text":""},{"location":"api/#md_spreadsheet_parser.core.clean_cell","title":"<code>clean_cell(cell_content, schema)</code>","text":"<p>Cleans a single cell content based on the schema.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def clean_cell(cell_content: str, schema: ParsingSchema) -&gt; str:\n    \"\"\"\n    Cleans a single cell content based on the schema.\n    \"\"\"\n    if schema.strip_whitespace:\n        return cell_content.strip()\n    return cell_content\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.is_separator_row","title":"<code>is_separator_row(row_cells, schema)</code>","text":"<p>Determines if a parsed row is a header separator row (e.g. ---|---).</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def is_separator_row(row_cells: list[str], schema: ParsingSchema) -&gt; bool:\n    \"\"\"\n    Determines if a parsed row is a header separator row (e.g. ---|---).\n    \"\"\"\n    if not row_cells:\n        return False\n\n    for cell in row_cells:\n        content = cell.strip()\n        if not content:\n            continue\n\n        valid_chars = set(schema.header_separator_char + \": \")\n        if not set(content).issubset(valid_chars):\n            return False\n\n        if schema.header_separator_char not in content:\n            return False\n\n    return True\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.parse_row","title":"<code>parse_row(line, schema)</code>","text":"<p>Parses a single line into a list of cell values.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def parse_row(line: str, schema: ParsingSchema) -&gt; list[str]:\n    \"\"\"\n    Parses a single line into a list of cell values.\n    \"\"\"\n    parts = line.split(schema.column_separator)\n\n    if not parts:\n        return []\n\n    start_idx = 0\n    end_idx = len(parts)\n\n    if parts and parts[0].strip() == \"\":\n        start_idx = 1\n\n    if parts and len(parts) &gt; 1 and parts[-1].strip() == \"\":\n        end_idx = -1\n\n    cleaned_parts = parts[start_idx:end_idx]\n\n    return [clean_cell(p, schema) for p in cleaned_parts]\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.parse_sheet","title":"<code>parse_sheet(text, name, schema=DEFAULT_SCHEMA)</code>","text":"<p>Parses a sheet content which may contain multiple tables. Supports splitting by table headers and extracting descriptions if configured.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def parse_sheet(text: str, name: str, schema: ParsingSchema = DEFAULT_SCHEMA) -&gt; Sheet:\n    \"\"\"\n    Parses a sheet content which may contain multiple tables.\n    Supports splitting by table headers and extracting descriptions if configured.\n    \"\"\"\n    tables = _extract_tables(text, schema)\n    return Sheet(name=name, tables=tables)\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.parse_table","title":"<code>parse_table(text, schema=DEFAULT_SCHEMA)</code>","text":"<p>Parses a single block of text into a table.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def parse_table(text: str, schema: ParsingSchema = DEFAULT_SCHEMA) -&gt; ParseResult:\n    \"\"\"\n    Parses a single block of text into a table.\n    \"\"\"\n    lines = text.strip().split(\"\\n\")\n\n    headers: list[str] | None = None\n    rows: list[list[str]] = []\n\n    potential_header: list[str] | None = None\n\n    for i, line in enumerate(lines):\n        line = line.strip()\n        if not line:\n            continue\n\n        parsed_row = parse_row(line, schema)\n\n        if not parsed_row:\n            continue\n\n        if headers is None and potential_header is not None:\n            if is_separator_row(parsed_row, schema):\n                headers = potential_header\n                potential_header = None\n                continue\n            else:\n                rows.append(potential_header)\n                potential_header = parsed_row\n        elif headers is None and potential_header is None:\n            potential_header = parsed_row\n        else:\n            rows.append(parsed_row)\n\n    if potential_header is not None:\n        rows.append(potential_header)\n\n    return ParseResult(\n        headers=headers, rows=rows, metadata={\"schema_used\": str(schema)}\n    )\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.parse_workbook","title":"<code>parse_workbook(text, schema)</code>","text":"<p>Parses a full workbook text containing multiple sheets. Strictly requires the root_marker to be present. Content before the marker is ignored.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def parse_workbook(text: str, schema: MultiTableParsingSchema) -&gt; Workbook:\n    \"\"\"\n    Parses a full workbook text containing multiple sheets.\n    Strictly requires the root_marker to be present. Content before the marker is ignored.\n    \"\"\"\n    # Find the root marker\n    marker_index = text.find(schema.root_marker)\n    if marker_index == -1:\n        return Workbook(sheets=[])\n\n    content_start = marker_index + len(schema.root_marker)\n    content = text[content_start:]\n\n    lines = content.split(\"\\n\")\n\n    sheets: list[Sheet] = []\n    current_sheet_name: str | None = None\n    current_sheet_lines: list[str] = []\n\n    header_prefix = \"#\" * schema.sheet_header_level + \" \"\n\n    for line in lines:\n        stripped = line.strip()\n        if stripped.startswith(header_prefix):\n            if current_sheet_name:\n                sheet_content = \"\\n\".join(current_sheet_lines)\n                sheets.append(parse_sheet(sheet_content, current_sheet_name, schema))\n\n            current_sheet_name = stripped[len(header_prefix) :].strip()\n            current_sheet_lines = []\n        else:\n            if current_sheet_name:\n                current_sheet_lines.append(line)\n\n    if current_sheet_name:\n        sheet_content = \"\\n\".join(current_sheet_lines)\n        sheets.append(parse_sheet(sheet_content, current_sheet_name, schema))\n\n    return Workbook(sheets=sheets)\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.core.scan_tables","title":"<code>scan_tables(text, schema=DEFAULT_SCHEMA)</code>","text":"<p>Scans the entire text for tables. If schema is configured with table_header_level, it attempts to extract named tables and descriptions. Otherwise, it ignores hierarchy and headers, returning a flat list of all found tables.</p> Source code in <code>src/md_spreadsheet_parser/core.py</code> <pre><code>def scan_tables(text: str, schema: ParsingSchema = DEFAULT_SCHEMA) -&gt; list[Table]:\n    \"\"\"\n    Scans the entire text for tables.\n    If schema is configured with table_header_level, it attempts to extract named tables and descriptions.\n    Otherwise, it ignores hierarchy and headers, returning a flat list of all found tables.\n    \"\"\"\n    return _extract_tables(text, schema)\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas","title":"<code>md_spreadsheet_parser.schemas</code>","text":""},{"location":"api/#md_spreadsheet_parser.schemas.MultiTableParsingSchema","title":"<code>MultiTableParsingSchema</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParsingSchema</code></p> <p>Configuration for parsing multiple tables (workbook mode).</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass MultiTableParsingSchema(ParsingSchema):\n    \"\"\"\n    Configuration for parsing multiple tables (workbook mode).\n    \"\"\"\n\n    root_marker: str = \"# Tables\"\n    sheet_header_level: int = 2  # e.g. ## SheetName\n    table_header_level: int | None = None  # e.g. ### TableName\n    capture_description: bool = False\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.ParseResult","title":"<code>ParseResult</code>  <code>dataclass</code>","text":"<p>Structured result of the parsing operation.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass ParseResult:\n    \"\"\"\n    Structured result of the parsing operation.\n    \"\"\"\n\n    headers: list[str] | None\n    rows: list[list[str]]\n    metadata: dict[str, Any]\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.ParsingSchema","title":"<code>ParsingSchema</code>  <code>dataclass</code>","text":"<p>Configuration for parsing markdown tables. Designed to be immutable and passed to pure functions.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass ParsingSchema:\n    \"\"\"\n    Configuration for parsing markdown tables.\n    Designed to be immutable and passed to pure functions.\n    \"\"\"\n\n    column_separator: str = \"|\"\n    header_separator_char: str = \"-\"\n    require_outer_pipes: bool = False\n    strip_whitespace: bool = True\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.Sheet","title":"<code>Sheet</code>  <code>dataclass</code>","text":"<p>Represents a single sheet containing tables.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass Sheet:\n    \"\"\"\n    Represents a single sheet containing tables.\n    \"\"\"\n\n    name: str\n    tables: list[Table]\n\n    @property\n    def json(self) -&gt; SheetJSON:\n        return {\"name\": self.name, \"tables\": [t.json for t in self.tables]}\n\n    def get_table(self, name: str) -&gt; Table | None:\n        \"\"\"\n        Retrieve a table by its name. Returns None if not found.\n        \"\"\"\n        for table in self.tables:\n            if table.name == name:\n                return table\n        return None\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.Sheet.get_table","title":"<code>get_table(name)</code>","text":"<p>Retrieve a table by its name. Returns None if not found.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>def get_table(self, name: str) -&gt; Table | None:\n    \"\"\"\n    Retrieve a table by its name. Returns None if not found.\n    \"\"\"\n    for table in self.tables:\n        if table.name == name:\n            return table\n    return None\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.Table","title":"<code>Table</code>  <code>dataclass</code>","text":"<p>Represents a parsed table with optional metadata.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass Table:\n    \"\"\"\n    Represents a parsed table with optional metadata.\n    \"\"\"\n\n    headers: list[str] | None\n    rows: list[list[str]]\n    name: str | None = None\n    description: str | None = None\n    metadata: dict[str, Any] | None = None\n\n    def __post_init__(self):\n        if self.metadata is None:\n            # Hack to allow default value for mutable type in frozen dataclass\n            object.__setattr__(self, \"metadata\", {})\n\n    @property\n    def json(self) -&gt; TableJSON:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"headers\": self.headers,\n            \"rows\": self.rows,\n            \"metadata\": self.metadata if self.metadata is not None else {},\n        }\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.Workbook","title":"<code>Workbook</code>  <code>dataclass</code>","text":"<p>Represents a collection of sheets (multi-table output).</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>@dataclass(frozen=True)\nclass Workbook:\n    \"\"\"\n    Represents a collection of sheets (multi-table output).\n    \"\"\"\n\n    sheets: list[Sheet]\n\n    @property\n    def json(self) -&gt; WorkbookJSON:\n        return {\"sheets\": [s.json for s in self.sheets]}\n\n    def get_sheet(self, name: str) -&gt; Sheet | None:\n        \"\"\"\n        Retrieve a sheet by its name. Returns None if not found.\n        \"\"\"\n        for sheet in self.sheets:\n            if sheet.name == name:\n                return sheet\n        return None\n</code></pre>"},{"location":"api/#md_spreadsheet_parser.schemas.Workbook.get_sheet","title":"<code>get_sheet(name)</code>","text":"<p>Retrieve a sheet by its name. Returns None if not found.</p> Source code in <code>src/md_spreadsheet_parser/schemas.py</code> <pre><code>def get_sheet(self, name: str) -&gt; Sheet | None:\n    \"\"\"\n    Retrieve a sheet by its name. Returns None if not found.\n    \"\"\"\n    for sheet in self.sheets:\n        if sheet.name == name:\n            return sheet\n    return None\n</code></pre>"}]}